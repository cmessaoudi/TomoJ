/*
 * Copyright 2010 Nick Aschman.
 */

package fr.curie.eftemtomoj.gui;
import fr.curie.eftemtomoj.Mapper.Model;
import fr.curie.eftemtomoj.Mapper.ImageType;

import fr.curie.eftemtomoj.*;
import ij.ImagePlus;
import ij.ImageStack;
import ij.gui.Roi;
import ij.process.ImageProcessor;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

/**
 * @author Nick Aschman
 */
public class MappingPanel extends WizardPage implements MouseListener {

    JPanel panel1;
    JComboBox backgroundModelComboBox;
    JButton previewButton;
    JButton applyButton;
    JCheckBox createCorrelationCoefficientMapCheckBox;
    JScrollPane plotScrollPane;
    PlotPanel2 plotPanel;

    private ImageMinus controlImage = null;
    private Mapper mapper;
    private static final int N_REG_POINTS = 300;

    public MappingPanel(WizardDialog dialog) {
        super(dialog, "MAPPING_PAGE" + Math.random(), "Elemental Mapping");

        $$$setupUI$$$();
        previewButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent actionEvent) {
                onPreview();
            }
        });
        applyButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent actionEvent) {
                onApply();
            }
        });
        backgroundModelComboBox.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ae) {
                if (mapper != null) {
                    mapper.setModel(Model.valueOf((String) backgroundModelComboBox.getSelectedItem()));
                    onFitRegression();
                }
            }
        });
        plotPanel.addPropertyChangeListener(new PropertyChangeListener() {
            public void propertyChange(PropertyChangeEvent pce) {
                if (pce.getPropertyName().equals(PlotPanel2.SELECTION_PROPERTY) && mapper != null) {
                    System.out.println("Selection");
                    ImageType[] imageTypes = plotPanel.getSelection();
                    for (int i = 0; i < imageTypes.length; i++) {
                        System.out.println("#" + i + ": " + imageTypes[i].name());

                        if (imageTypes[i] == ImageType.Background) {
                            mapper.setBackground(i);
                        } else if (imageTypes[i] == ImageType.Signal) {
                            mapper.setSignal(i);
                        } else {
                            mapper.setDisabled(i);
                        }
                    }

                    onFitRegression();
                }
            }
        });

        // Create list of alignment metrics
        Model[] mod = Model.values();

        String[] models = new String[mod.length];
        for (int i = 0; i < models.length; i++)
            models[i] = mod[i].name();

        backgroundModelComboBox.setModel(new DefaultComboBoxModel(models));

    }

    private void createUIComponents() {
        backgroundModelComboBox = new JComboBox();
        plotPanel = new PlotPanel2();
    }

    /**
     * Method generated by IntelliJ IDEA GUI Designer
     * >>> IMPORTANT!! <<<
     * DO NOT edit this method OR call it in your code!
     *
     * @noinspection ALL
     */
    private void $$$setupUI$$$() {
        createUIComponents();
        panel1 = new JPanel();
        panel1.setLayout(new com.intellij.uiDesigner.core.GridLayoutManager(5, 4, new Insets(0, 0, 0, 0), -1, -1));
        final JSeparator separator1 = new JSeparator();
        panel1.add(separator1, new com.intellij.uiDesigner.core.GridConstraints(1, 0, 1, 4, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER, com.intellij.uiDesigner.core.GridConstraints.FILL_BOTH, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));
        final JLabel label1 = new JLabel();
        label1.setFont(new Font(label1.getFont().getName(), Font.BOLD, label1.getFont().getSize()));
        label1.setText("Background subtraction");
        panel1.add(label1, new com.intellij.uiDesigner.core.GridConstraints(2, 0, 1, 4, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST, com.intellij.uiDesigner.core.GridConstraints.FILL_NONE, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        final JLabel label2 = new JLabel();
        label2.setText("Model:");
        panel1.add(label2, new com.intellij.uiDesigner.core.GridConstraints(3, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST, com.intellij.uiDesigner.core.GridConstraints.FILL_NONE, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        previewButton = new JButton();
        previewButton.setText("Preview map");
        panel1.add(previewButton, new com.intellij.uiDesigner.core.GridConstraints(3, 3, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER, com.intellij.uiDesigner.core.GridConstraints.FILL_HORIZONTAL, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        applyButton = new JButton();
        applyButton.setText("Create map");
        panel1.add(applyButton, new com.intellij.uiDesigner.core.GridConstraints(4, 3, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER, com.intellij.uiDesigner.core.GridConstraints.FILL_HORIZONTAL, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        createCorrelationCoefficientMapCheckBox = new JCheckBox();
        createCorrelationCoefficientMapCheckBox.setText("Create R2 plot");
        panel1.add(createCorrelationCoefficientMapCheckBox, new com.intellij.uiDesigner.core.GridConstraints(4, 1, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST, com.intellij.uiDesigner.core.GridConstraints.FILL_NONE, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        plotScrollPane = new JScrollPane();
        plotScrollPane.setVerticalScrollBarPolicy(21);
        panel1.add(plotScrollPane, new com.intellij.uiDesigner.core.GridConstraints(0, 0, 1, 4, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER, com.intellij.uiDesigner.core.GridConstraints.FILL_BOTH, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false));
        plotScrollPane.setViewportView(plotPanel);
        final JPanel panel2 = new JPanel();
        panel2.setLayout(new com.intellij.uiDesigner.core.GridLayoutManager(1, 2, new Insets(0, 0, 0, 0), -1, -1));
        panel1.add(panel2, new com.intellij.uiDesigner.core.GridConstraints(3, 1, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER, com.intellij.uiDesigner.core.GridConstraints.FILL_BOTH, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));
        panel2.add(backgroundModelComboBox, new com.intellij.uiDesigner.core.GridConstraints(0, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST, com.intellij.uiDesigner.core.GridConstraints.FILL_HORIZONTAL, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        final com.intellij.uiDesigner.core.Spacer spacer1 = new com.intellij.uiDesigner.core.Spacer();
        panel2.add(spacer1, new com.intellij.uiDesigner.core.GridConstraints(0, 1, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER, com.intellij.uiDesigner.core.GridConstraints.FILL_HORIZONTAL, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));
        final com.intellij.uiDesigner.core.Spacer spacer2 = new com.intellij.uiDesigner.core.Spacer();
        panel1.add(spacer2, new com.intellij.uiDesigner.core.GridConstraints(4, 2, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER, com.intellij.uiDesigner.core.GridConstraints.FILL_HORIZONTAL, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));
    }

    @Override
    public JComponent getComponent() {
        return panel1;
    }

    @Override
    public boolean validate() {
        System.out.println("mapping validated");
        final EftemDataset ds = dialog.getCurrentDataset();
        TiltSeries[] ts = ds.getTiltSeries();
        ImageType[] imageTypes = plotPanel.getSelection();
        int offset = 0;
        for (int i = 0; i < imageTypes.length; i++) {
            while (!ts[i + offset].isUsedForMapping()) {
                offset++;
            }
            System.out.println("#" + i + ": " + imageTypes[i].name());

            if (imageTypes[i] == ImageType.Background) {
                ts[i + offset].setUseForMapping(true);
            } else if (imageTypes[i] == ImageType.Signal) {
                ts[i + offset].setUseForMapping(true);
                ts[i + offset].setSignal(true);
            } else {
                ts[i + offset].setUseForMapping(false);
            }
            System.out.println(ts[i + offset].getEnergyShift() + " used for mapping:" + ts[i + offset].isUsedForMapping());
        }
        ds.tiltSeriesUpdated();
        ds.setLaw(Model.valueOf((String) backgroundModelComboBox.getSelectedItem()));

        hideControlImage();
        return true;
    }

    @Override
    public void activate() {
        System.out.println("mapping activated");
        final EftemDataset ds = dialog.getCurrentDataset();

        if (ds == null) {
            System.out.println("Error: No dataset found");//TODO
            return;
        }
        ds.correctNegativeValues();
        // Create new mapper if needed and select model
        if (mapper == null) mapper = new Mapper(ds);
        //else System.out.println("mapper not null");
        backgroundModelComboBox.setSelectedItem(mapper.getModel().toString());

        // Create and show image
        FilteredImage[] img = ds.getMappingImages();
        System.out.println("number of images for mapping:" + img.length);
        ImageStack stack = new ImageStack(ds.getWidth(), ds.getHeight());
        for (FilteredImage anImg : img) {
            stack.addSlice(anImg.getEnergyShift() + "eV", anImg.getImage());

        }

        showControlImage(stack);

        // Update plot
        onFitRegression();
    }

    @Override
    public boolean abort() {
        hideControlImage();
        return true;
    }

    private void showControlImage(ImageStack stack) {
        hideControlImage();

        controlImage = new ImageMinus("Preview", stack);
        controlImage.show();
        controlImage.getCanvas().addMouseListener(this);
    }

    private void hideControlImage() {
        if (controlImage != null) {
            controlImage.setAllowedToClose(true);
            controlImage.close();
        }
    }

    private void onPreview() {
        if (mapper == null) {
            return; //TODO this shouldn't happen
        }

        // Compute map at zero tilt only
        ImageProcessor[] maps = null;

        final WizardApprentice worker = new WizardApprentice<ImageProcessor[]>(dialog, "Computing elemental map (zero-tilt only)") {
            @Override
            protected ImageProcessor[] doInBackground() throws Exception {
                ImageProcessor[] maps;

                mapper.addObserver(this);
                maps = mapper.computeMap();
                mapper.removeObserver(this);

                return maps;
            }
        };
        worker.go();

        try {
            maps = (ImageProcessor[]) worker.get();
        } catch (Exception ex) {
            ex.printStackTrace();
            JOptionPane.showMessageDialog(dialog, ex.getMessage(), "Process aborted", JOptionPane.ERROR_MESSAGE);
//	    ex.printStackTrace();
            return;
        }

        // Save and show results
        dialog.setCursor(new Cursor(Cursor.WAIT_CURSOR));
        ImagePlus mapStack = new ImagePlus("Elemental maps " + mapper.getModel() + " law " + mapper.usedEnergyAsString(), maps[0]);
        ImagePlus r2MapStack = new ImagePlus("Correlation coefficient maps (" + mapper.getModel() + ")", maps[1]);

        dialog.getCurrentDataset().saveImageAs(mapStack, "preview-map.tif");
        mapStack.show();

        if (createCorrelationCoefficientMapCheckBox.isSelected()) {
            dialog.getCurrentDataset().saveImageAs(r2MapStack, "preview-r2map.tif");
            r2MapStack.show();
        }
        dialog.setCursor(Cursor.getDefaultCursor());
    }

    private void onApply() {
        if (mapper == null) {
            return; //TODO this shouldn't happen
        }

        // Compute all maps
        final EftemDataset ds = dialog.getCurrentDataset();
        ImageStack[] stacks = null;

        final WizardApprentice worker = new WizardApprentice<ImageStack[]>(dialog, "Computing elemental maps") {
            @Override
            protected ImageStack[] doInBackground() throws Exception {
                ImageStack[] stacks;

                mapper.addObserver(this);
                stacks = mapper.computeMaps(ds);
                mapper.removeObserver(this);

                return stacks;
            }
        };
        worker.go();

        try {
            stacks = (ImageStack[]) worker.get();
        } catch (Exception ex) {
            ex.printStackTrace();
            JOptionPane.showMessageDialog(dialog, ex.getMessage(), "Process aborted", JOptionPane.ERROR_MESSAGE);
//	    ex.printStackTrace();
            return;
        }

        // Save and show results
        dialog.setCursor(new Cursor(Cursor.WAIT_CURSOR));
        ImagePlus mapStack = new ImagePlus("Elemental maps " + mapper.getModel() + " law " + mapper.usedEnergyAsString(), stacks[0]);
        ImagePlus r2MapStack = new ImagePlus("Correlation coefficient maps (" + mapper.getModel() + ")", stacks[1]);

        ds.saveImageAs(mapStack, "maps.tif");
        mapStack.show();

        if (createCorrelationCoefficientMapCheckBox.isSelected()) {
            ds.saveImageAs(r2MapStack, "r2map.tif");
            r2MapStack.show();
        }
        dialog.setCursor(Cursor.getDefaultCursor());
    }

    private void onFitRegression() {
        if (mapper != null) {

            Roi roi = null;
            if (controlImage != null) {
                roi = controlImage.getRoi();
            }

            try {
                plotPanel.setData(mapper, roi);
                plotPanel.setRegression(mapper.computeRegressionCurve(N_REG_POINTS, roi));
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
    }

    public void mouseClicked(MouseEvent me) {
        onFitRegression();
    }

    public void mousePressed(MouseEvent me) {
        // Do nothing
    }

    public void mouseReleased(MouseEvent me) {
        onFitRegression();
    }

    public void mouseEntered(MouseEvent me) {
        // Do nothing
    }

    public void mouseExited(MouseEvent me) {
        // Do nothing
    }

}
